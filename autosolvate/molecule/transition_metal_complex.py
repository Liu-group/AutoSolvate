import getopt
import sys
import os
import shutil
import subprocess
import pkg_resources
import glob
import logging

from typing import Any, List, Tuple, TextIO
from dataclasses import dataclass, field, asdict

from parmed.amber import AmberParm, AmberParameterSet
from parmed.topologyobjects import Atom, Bond, Angle, Dihedral, Improper, Residue
from parmed.structure import Structure
import parmed as pmd


from autosolvate.Common import *
from autosolvate.utils import *
from autosolvate.molecule import *


class TransitionMetalComplex(System):
    """
    This data class is only responsible for holding the transition metal complex data.
    IMPORTANT: The current version requires the results generated by MCPB.py or AutoMCPB.
    """

    #constants 
    _SUPPORT_INPUT_FORMATS = ['pdb', 'xyz', "mol2"] 
    # other
    def __init__(
            self, 
            pdbfile:        str, 
            charge:         int, 
            multiplicity:   int,
            prmtop:         str,
            origin_folder   = "", 
            metal_residue_names: List[str] = [],
            name            = "",
            residue_name    = "MOL",
            folder          = WORKING_DIR,
            ) -> None:
        """
        This data class is only responsible for holding the transition metal complex data.
        IMPORTANT: The current version requires the results generated by MCPB.py or AutoMCPB.

        Parameters
        ----------
        pdbfile : str
            pdb file of the transition metal complex. This cannot be a xyz file because the pdb file contains the residue information.  # copilot is even more smart than me （本来挺喜欢你的结果你开始自以为是了）
        charge : int
            charge of the transition metal complex.
        multiplicity : int
            multiplicity of the transition metal complex.
        prmtop : str
            prmtop file of the transition metal complex, generated by MCPB.py or AutoMCPB. This file is required in the current version.
        origin_folder : str, optional
            The folder contains the mol2 files of metal and legand, by default "", which means the folder is the same as the prmtop file.
        metal_residue_names : List[str], optional
            The residue names of the metal atoms, by default [], which means the residue names will be determined as the first residue with only one atom.
        name : str, optional
            The name of the transition metal complex, by default "", which means the name will be generated from the pdb file.
        residue_name : str, optional
            The residue name of the transition metal complex, by default "MOL".
        folder : str, optional
            The folder to store the files generated by this class, by default WORKING_DIR.
        """

        self.name           = process_system_name(name, pdbfile, support_input_format = Molecule._SUPPORT_INPUT_FORMATS)
        self.folder         = os.path.abspath(folder)
        self.charge         = charge
        self.multiplicity   = multiplicity
        self.spinmult       = multiplicity
        self.residue_name   = residue_name
        self.number         = 0
        self.prmtop         = prmtop
        self.origin_folder  = origin_folder if origin_folder else os.path.dirname(self.prmtop)
        self.origin_folder  = os.path.abspath(self.origin_folder)

        self.pdb            = pdbfile
    
        super(TransitionMetalComplex, self).__init__(name = self.name)
        self.logger.name = self.__class__.__name__

        if isinstance(metal_residue_names, str):
            metal_residue_names = [metal_residue_names, ]
        self.metal_residue_names = metal_residue_names
        self.legand_residue_names = []
        self.metal_legand_bonds = []
        self.metal_mol2_files = []
        self.legand_mol2_files = []
        self.check_system()

    def create_frcmod_from_prmtop(self):
        amberparams = AmberParameterSet.from_structure(self.pmd_structure)
        amberparams.write(f"{self.folder}/{self.name}.frcmod")
        self.frcmod = f"{self.folder}/{self.name}.frcmod"
        self.logger.info(f"Create frcmod file from prmtop: {self.frcmod}")

    def check_system(self):
        if not os.path.exists(self.origin_folder):
            logger.error(f"Origin folder for AutoMCPB output files {self.origin_folder} does not exist")
            raise FileNotFoundError
        if not os.path.exists(self.prmtop):
            logger.error(f"Prmtop file generated by AutoMCPB {self.prmtop} does not exist")
            raise FileNotFoundError
        self.pmd_structure = AmberParm(self.prmtop, xyz=self.pdb)
        self.get_residues()
        self.metal_legand_bonds = self.get_bond_connect_with_metal()
        for metal_residue_name in self.metal_residue_names:
            if not os.path.exists(f"{self.origin_folder}/{metal_residue_name}.mol2"):
                logger.error(f"Metal residue {metal_residue_name}.mol2 does not exist.")
                raise FileNotFoundError
            self.logger.info(f"Find mol2 for {metal_residue_name}: {self.origin_folder}/{metal_residue_name}.mol2")
            self.metal_mol2_files.append(f"{self.origin_folder}/{metal_residue_name}.mol2")
        for legand_residue_name in self.legand_residue_names:
            if not os.path.exists(f"{self.origin_folder}/{legand_residue_name}.mol2"):
                logger.error(f"Legand residue {legand_residue_name}.mol2 does not exist.")
                raise FileNotFoundError
            self.logger.info(f"Find mol2 for {legand_residue_name}: {self.origin_folder}/{legand_residue_name}.mol2")
            self.legand_mol2_files.append(f"{self.origin_folder}/{legand_residue_name}.mol2")
        self.create_frcmod_from_prmtop()

    def get_residues(self):
        residues = self.pmd_structure.residues
        for residue in residues:
            self.logger.debug(f"Residue {residue.idx:>3d}: {residue.name:<3s}; {len(residue.atoms):>3d} atoms")
        if len(self.metal_residue_names) == 0:
            for residue in residues:
                if len(residue.atoms) == 1 and residue.atoms[0].element_name not in ["F", "Cl", "Br", "I"]:
                    self.metal_residue_names.append(residue.name)

        self.legand_residue_names = [residue.name for residue in residues if residue.name not in self.metal_residue_names]
        self.logger.info(f"Metal Residues: {self.metal_residue_names}")
        self.logger.info(f"Legand Residues: {self.legand_residue_names}")
        return residues
    
    def get_bond_connect_with_metal(self):
        bonds = []
        for bond in self.pmd_structure.bonds:
            if bond.atom1.residue.name in self.metal_residue_names or bond.atom2.residue.name in self.metal_residue_names:
                bonds.append(bond)
                self.logger.info(f"Find metal-legand bond: {bond.atom1.residue.idx+1}.{bond.atom1.name} {bond.atom2.residue.idx+1}.{bond.atom2.name}")
        return bonds
    
    def write_tleap_load_command(self, tleap_inp:TextIO):
        for metres, metmol2 in zip(self.metal_residue_names, self.metal_mol2_files):
            tleap_inp.write(f"{metres:<3s} = loadmol2 {metmol2}\n")
        for legres, legmol2 in zip(self.legand_residue_names, self.legand_mol2_files):
            tleap_inp.write(f"{legres:<3s} = loadmol2 {legmol2}\n")
        tleap_inp.write(f"loadamberparams {self.frcmod}\n")

    def find_out_real_residue_index(self, solvated_pdb:str):
        self.logger.info(f"Find out real residue index from {solvated_pdb}")
        tmc_res_indices = []
        solvated_sys = pmd.load_file(solvated_pdb, skip_bonds = True)
        solvated_sys:pmd.Structure
        sys_resnames = [residue.name for residue in solvated_sys.residues]
        tmpdict = {}
        for residue in self.pmd_structure.residues:
            tmpdict[residue.name] = []
            for i, sys_resname in enumerate(sys_resnames):
                if residue.name == sys_resname:
                    tmpdict[residue.name].append(i)
        # check all list in tmpdict has the same length
        for key in tmpdict.keys():
            self.logger.info(f"The system contains {len(tmpdict[key])} {key}" + f" with indices {tmpdict[key]}")
            if len(tmpdict[key]) != len(tmpdict[list(tmpdict.keys())[0]]):
                logger.error(f"The number of {key} is different from others!")
                logger.error(f"This may indicate an incomplete transition metal complex structure")
                raise ValueError
        for i in range(len(tmpdict[list(tmpdict.keys())[0]])):
            tmc_res_index = {}
            for key in tmpdict.keys():
                tmc_res_index[key] = tmpdict[key][i]
            tmc_res_indices.append(tmc_res_index)
        return tmc_res_indices

    def write_tleap_add_bond_command(self, tleap_inp:TextIO, solvated_pdb:str = None, system_name:str = "SYS"):
        bonds = self.metal_legand_bonds
        if not solvated_pdb:
            tmc_res_indices = []
            residues = self.pmd_structure.residues
            tmc_res_index = {}
            for residue in residues:
                tmc_res_index[residue.name] = residue.idx
            tmc_res_indices.append(tmc_res_index)
        else:
            tmc_res_indices = self.find_out_real_residue_index(solvated_pdb)

        for bond in bonds:
            a1, a2 = bond.atom1, bond.atom2
            res1, res2 = a1.residue.name, a2.residue.name
            for tmc_res_index in tmc_res_indices:
                res1_index, res2_index = tmc_res_index[res1], tmc_res_index[res2]
                tleap_inp.write(f"bond {system_name}.{res1_index + 1}.{a1.name} {system_name}.{res2_index + 1}.{a2.name}\n")

        
if __name__ == "__main__":
    slv_pdbfile = "/home/fren5/AutoSolvae-update/Co_plus3_bpy3_IL_solvated/Co_plus3_bpy3_IL_solvated.pdb"
    slv_prmtop = "/home/fren5/AutoSolvae-update/Co_plus3_bpy3_IL_solvated/Co_plus3_bpy3_IL_solvated.prmtop"
    origin_folder = "/home/fren5/AutoSolvae-update/FFgen"

    pdbfile = "/home/fren5/AutoSolvae-update/FFgen/Co_plus3_dry.pdb"
    prmtop = "/home/fren5/AutoSolvae-update/FFgen/Co_plus3_dry.prmtop"
    tmc = TransitionMetalComplex(pdbfile, 3, 1, prmtop, origin_folder, metal_residue_names = ["CO1"], folder = "tmc_test")
    f = open("sample_tleap_in.cmd", "w")
    tmc.write_tleap_load_command(f)
    tmc.write_tleap_add_bond_command(f, slv_pdbfile)