# @TODO: 
# 1. do we want output format to be .prep? 
# 2. add parmchk command (maybe a class)

# @NOTE: 
# 1. check if 'mol: object' usage is valid 
#    - yes, I think it is valid 
# 2. this does not need to be a class 
#    - yes it is a functional oriented class 
import getopt, sys, os, subprocess


from .general_docker import GeneralDocker
from ..molecule import *
from ..utils import srun


class AntechamberDocker(GeneralDocker):

    _SUPPORT_INPUT_FORMATS           = ['pdb']
    _SUPPORT_CHARGE_FITTING_METHODS  = ['bcc']

    def __init__(self, 
                 charge_method:         str = 'bcc', 
                 out_format:            str = 'mol2',
                 workfolder:            str = WORKING_DIR,
                 exeoutfile:            str = "antechamber.log",
                 eq:                    int = 2,
                 pl:                    int = -1,
                 
    ) -> None:      
        #setting
        super(AntechamberDocker, self).__init__(
            executable = "antechamber",
            workfolder = workfolder,
            exeoutfile = exeoutfile)
        self.out_format                 = out_format
        self.charge_method              = charge_method
        self.eq = eq
        self.pl = pl
        self.logger.name = self.__class__.__name__

        self.outfile = ""

    def generate_outputfile_name(self, mol: System, fmt:str) -> str:
        newname = mol.reference_name + "." + fmt
        self.logger.info("The output '{}' file will be generated at {}".format(fmt, newname))
        return newname
    
    def removeConectFromPDB(self, mol:System):
        # This function is generated by ChatGPT
        self.logger.info("Removing the CONECT section from system PDB: {}".format(mol.pdb))
        input_file = mol.pdb
        output_file = os.path.splitext(input_file)[0] + '_noCONECT.pdb'
        try:
            with open(input_file , "r") as reader, open(output_file, "w") as writer:
                for line in reader:
                    if 'CONECT' not in line:
                        writer.write(line)
            os.replace(output_file, input_file) 
            self.logger.info(
            f"successfully completed removing CONECT section, old pdb file backed up at {output_file} ")
        except Exception as e:
            self.logger.exception(f"{type(e).__name__} while removing CONECTs")
            raise # reraising exceptions to stop furthur processing

    def check_system(self, mol: System) -> bool:
        passflag = 1
        self.logger.info("Checking system {:s}...".format(mol.name))
        sysattrs = ["name", "charge", "multiplicity", "residue_name"]
        if not isinstance(mol, Molecule):
            self.logger.critical("Only single molecule is supported!")
            raise TypeError("Only single molecule is supported!")
        if mol.check_exist("pdb"):
            self.logger.info("System PDB: {:s}".format(mol.pdb))
        else:
            self.logger.critical("PDB file not exist! System PDB: %s", mol.pdb, exc_info=1)
            passflag = 0
        for attr in sysattrs:
            if getattr(mol, attr) is None:
                self.logger.critical("Improper parameter detected! {}.{}\t={}".format(mol.name, attr, getattr(mol, attr)))
                passflag = 0
            else:
                self.logger.info("{}.{}\t={}".format(mol.name, attr, getattr(mol, attr)))
        if self.charge_method == "bcc" and int(mol.multiplicity) > 1:
            self.logger.critical("spin multiplicity: {}, charge method {}".format(mol.multiplicity, self.charge_method))
            self.logger.critical("atomic charge fitting for open-shell system only works for resp charge method!")
            passflag = 0
        if not passflag:
            raise RuntimeError("Critical errors encountered.")
    @srun()
    def generate_cmd(self, mol: System) -> str:
        '''
        @EXAMPLE: 
        $AMBERHOME/bin/antechamber -i 1.pdb -fi pdb -o 1.mol2 -fo mol2 -c bcc -nc 0 -m 1 -rn MOL
        '''
        outname = self.generate_outputfile_name(mol, self.out_format)
        args = [   
            "{}".format(self.executable),
            "-i"    ,"{}".format(mol.pdb),
            "-fi"   ,"{}".format("pdb"),
            "-o"    ,"{}".format(outname),
            "-fo"   ,"{}".format(self.out_format),
            "-c"    ,"{}".format(self.charge_method),
            "-nc"   ,"{}".format(mol.charge),
            "-m"    ,"{}".format(mol.multiplicity),
            "-rn"   ,"{}".format(mol.residue_name),
            "-eq"   ,"{}".format(self.eq),
            "-pl"   ,"{}".format(self.pl),
        ]
        cmd = " ".join(args)
        return cmd 
        
    def generate_input(self, mol: System):
        pass

    def predict_output(self, mol: System):
        outname = self.generate_outputfile_name(mol, self.out_format)
        self.logger.info("The {} file will be generated at {}".format(self.out_format, outname))
        self.outfile = outname
        if os.path.exists(outname):
            self.logger.info("Found a existing file with the same name: {}".format(outname))
            self.logger.info("This file will be Overwritten!".format(outname))

    def check_output(self, mol: System):
        success = True
        mol2file = self.outfile
        if os.path.exists(mol2file):
            self.logger.info("Successfully generated target {} file: {}".format(self.out_format, mol2file))
            success = True
        else:
            self.logger.critical("Failed to generate target {} file: {}".format(self.out_format, mol2file))
            success = False
        if not success:
            raise RuntimeError
        
    def process_output(self, mol: System):
        mol2file = self.outfile
        setattr(mol, self.out_format, mol2file)
        mol.update()

    def run(self, mol:System):
        self.logger.name = self.__class__.__name__
        self.check_system(mol)
        self.removeConectFromPDB(mol)
        self.predict_output(mol)
        self.generate_input(mol)
        cmd = self.generate_cmd(mol)
        self.execute(cmd)
        self.check_output(mol)
        self.process_output(mol)
        



if __name__ == '__main__': 
    import doctest

    # global DRY_RUN 
    DRY_RUN = True

    doctest.testmod() 
    